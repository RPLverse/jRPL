/**
 * Copyright (c) 2025 Massimo Costantini.
 * Licensed under the Apache License, Version 2.0.
 * See the LICENSE file in the project root for full license information.
 */

package org.jrpl.compiler.codegen;

import org.jrpl.compiler.ir.*;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

import java.util.List;

import static org.objectweb.asm.Opcodes.*;

/**
 * Emits bytecode instructions for each element of the jRPL IR.
 *
 * <p>{@code IrEmitter} does not generate an entire class; it only translates
 * a sequence of IR nodes into ASM bytecode using the provided {@link MethodVisitor}.
 *
 * <h2>Responsibilities:</h2>
 * <ul>
 *   <li>Map each IR node type ({@link PushConst}, {@link Dup}, {@link BinOp}, etc.)
 *       to a corresponding call on the {@link org.jrpl.runtime.ExecStack} stack object.</li>
 *   <li>Emit structured control flow for {@link IfElse} nodes.</li>
 *   <li>Ensure the generated bytecode leaves the stack in a consistent state.</li>
 * </ul>
 *
 * <h2>Design:</h2>
 * <ul>
 *   <li>All instructions operate on the first method parameter (the {@code ExecStack} object).</li>
 *   <li>Helper methods reduce duplication (e.g. {@link #emitCall}).</li>
 *   <li>Conditional logic is implemented using ASM {@link Label}stack and jump opcodes.</li>
 * </ul>
 */
final class IrEmitter {
    private IrEmitter() {}

    /**
     * Emit a sequence of IR instructions.
     *
     * @param ir list of IR instructions
     * @param mv ASM method visitor for the current method
     */
    static void emit(List<Instruction> ir, MethodVisitor mv) {
        for (Instruction i : ir) {
            if (i instanceof PushConst pc) emitPush(pc, mv);
            else if (i instanceof Dup) emitCall(mv, "dup", "()V");
            else if (i instanceof Drop) emitCall(mv, "drop", "()V");
            else if (i instanceof Swap) emitCall(mv, "swap", "()V");
            else if (i instanceof BinOp b) emitBin(b, mv);
            else if (i instanceof CmpOp c) emitCmp(c, mv);
            else if (i instanceof IfElse ie) emitIfElse(ie, mv);
            else throw new IllegalArgumentException("Unknown IR: " + i.getClass());
        }
    }

    /** Push a constant double value onto the runtime stack. */
    private static void emitPush(PushConst pc, MethodVisitor mv) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitLdcInsn(pc.value);
        mv.visitMethodInsn(INVOKEVIRTUAL, "org/jrpl/runtime/ExecStack", "push", "(D)V", false);
    }

    /** Emit a call to a void method on the runtime stack (e.g. dup, drop, swap). */
    private static void emitCall(MethodVisitor mv, String name, String desc) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKEVIRTUAL, "org/jrpl/runtime/ExecStack", name, desc, false);
    }

    /** Emit a binary arithmetic operation. */
    private static void emitBin(BinOp b, MethodVisitor mv) {
        switch (b.kind) {
            case ADD -> emitCall(mv, "add", "()V");
            case SUB -> emitCall(mv, "sub", "()V");
            case MUL -> emitCall(mv, "mul", "()V");
            case DIV -> emitCall(mv, "div", "()V");
            case POW -> emitCall(mv, "pow", "()V");
        }
    }

    /** Emit a comparison operation (produces 0.0 or 1.0). */
    private static void emitCmp(CmpOp c, MethodVisitor mv) {
        switch (c.kind) {
            case GT -> emitCall(mv, "cmpGT", "()V");
            case LT -> emitCall(mv, "cmpLT", "()V");
            case GE -> emitCall(mv, "cmpGE", "()V");
            case LE -> emitCall(mv, "cmpLE", "()V");
            case EQ -> emitCall(mv, "cmpEQ", "()V");
            case NE -> emitCall(mv, "cmpNE", "()V");
        }
    }

    /**
     * Emit conditional control flow for an {@link IfElse} instruction.
     * <p>
     * The runtime stack is expected to contain a boolean value
     * (1.0 for true, 0.0 for false) on top. This value is popped
     * and used as the branch condition.
     * </p>
     */
    private static void emitIfElse(IfElse ie, MethodVisitor mv) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKEVIRTUAL, "org/jrpl/runtime/ExecStack", "pop", "()D", false);
        mv.visitInsn(DCONST_0);
        mv.visitInsn(DCMPL);

        Label thenL = new Label();
        Label endL = new Label();

        if (ie.elseBranch != null) {
            mv.visitJumpInsn(IFNE, thenL);
            emit(ie.elseBranch, mv);
            mv.visitJumpInsn(GOTO, endL);
            mv.visitLabel(thenL);
            emit(ie.thenBranch, mv);
            mv.visitLabel(endL);
        } else {
            mv.visitJumpInsn(IFEQ, endL);
            mv.visitLabel(thenL);
            emit(ie.thenBranch, mv);
            mv.visitLabel(endL);
        }
    }
}
